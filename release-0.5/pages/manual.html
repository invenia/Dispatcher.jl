<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · Dispatcher.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/invenia.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Dispatcher.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li class="current"><a class="toctext" href="manual.html">Manual</a><ul class="internal"><li><a class="toctext" href="#Motivation-1">Motivation</a></li><li><a class="toctext" href="#Design-1">Design</a></li><li><a class="toctext" href="#Further-Reading-1">Further Reading</a></li></ul></li><li><a class="toctext" href="api.html">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="manual.html">Manual</a></li></ul><a class="edit-page" href="https://github.com/invenia/Dispatcher.jl/blob/master/docs/src/pages/manual.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h1><h2><a class="nav-anchor" id="Motivation-1" href="#Motivation-1">Motivation</a></h2><p><code>Dispatcher.jl</code> is designed to distribute and manage execution of a graph of computations. These computations are specified in a manner as close to regular imperative Julia code as possible. Using a parallel executor with several processes, a central controller manages execution, but data is transported only among processes which will use it. This avoids having one large process where all data currently being used is stored.</p><h2><a class="nav-anchor" id="Design-1" href="#Design-1">Design</a></h2><h3><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h3><p>Using Dispatcher, <code>run!</code> builds and runs a computation graph of <code>DispatchNode</code>s. <code>DispatchNode</code>s represent units of computation that can be run. The most common <code>DispatchNode</code> is <code>Op</code>, which represents a function call on some arguments. Some of those arguments may exist when building the graph, and others may represent the results of other <code>DispatchNode</code>s. An <code>Executor</code> builds and executes a whole <code>DispatchGraph</code>. Two <code>Executor</code>s are provided. <code>AsyncExecutor</code> executes computations asynchronously using Julia <code>Task</code>s. <code>ParallelExecutor</code> executes computations in parallel using all available Julia processes (by calling <code>@spawn</code>).</p><p>Here is an example defining and executing a graph:</p><pre><code class="language-julia">filenames = [&quot;mydata-$d.dat&quot; for d in 1:100]
data = [(@op load(filename)) for filename in filenames]

reference = @op load_from_sql(&quot;sql://mytable&quot;)
processed = [(@op process(d, reference)) for d in data]

rolled = map(1:(length(processed) - 2)) do i
    a = processed[i]
    b = processed[i + 1]
    c = processed[i + 2]
    roll_result = @op roll(a, b, c)
    return roll_result
end

compared = map(1:200) do i
    a = rand(rolled)
    b = rand(rolled)
    compare_result = @op compare(a, b)
    return compare_result
end

best = @op reduction(CollectNode(compared))

executor = ParallelExecutor()
(run_best,) = run!(executor, [best])</code></pre><p>The components of this example will be discussed below. This example is based on <a href="http://matthewrocklin.com/blog/work/2017/01/24/dask-custom">a Dask example</a>.</p><h3><a class="nav-anchor" id="Dispatch-Nodes-1" href="#Dispatch-Nodes-1">Dispatch Nodes</a></h3><p>A <code>DispatchNode</code> generally represents a unit of computation that can be run. <code>DispatchNode</code>s are constructed when defining the graph and are run as part of graph execution. <code>CollectNode</code> from the above example is a subtype of <code>DispatchNode</code>.</p><p>Any arguments to <code>DispatchNode</code> constructors (including in <code>@op</code>) which are <code>DispatchNode</code>s are recorded as dependencies in the graph.</p><h3><a class="nav-anchor" id="Op-1" href="#Op-1">Op</a></h3><p>An <code>Op</code> is a <code>DispatchNode</code> which represents some function call to be run as part of graph execution. This is the most common type of <code>DispatchNode</code>. The <code>@op</code> macro deconstructs a function call to construct an <code>Op</code>. The following code:</p><pre><code class="language-julia">roll_result = @op roll(a, b, c)</code></pre><p>is equivalent to:</p><pre><code class="language-julia">roll_result = Op(roll, a, b, c)</code></pre><p>Note that code in the argument list gets evaluated immediately; only the function call is delayed.</p><h3><a class="nav-anchor" id="Executors-1" href="#Executors-1">Executors</a></h3><p>An <code>Executor</code> runs a <code>DispatchGraph</code>. This package currently provides two <code>Executor</code>s: <code>AsyncExecutor</code> and <code>ParallelExecutor</code>. They work the same way, except <code>AsyncExecutor</code> runs nodes using <code>@async</code> and <code>ParallelExecutor</code> uses <code>@spawn</code>.</p><p>This call:</p><pre><code class="language-julia">(run_best,) = run!(executor, [best])</code></pre><p>takes an <code>Executor</code> and a <code>Vector{DispatchNode}</code>, creates a <code>DispatchGraph</code> of those nodes and all of their ancestors, runs it, and returns a collection of <code>DispatchResult</code>s (in this case containing only the <code>DispatchResult</code> for <code>best</code>). A <code>DispatchResult</code> is a <a href="https://github.com/iamed2/ResultTypes.jl"><code>ResultType</code></a> containing either a <code>DispatchNode</code> or a <code>DependencyError</code> (an error that occurred when attempting to satisfy the requirements for running that node).</p><p>It is also possible to feed in inputs in place of nodes in the graph; see <a href="pages/api.html#Dispatcher.run!-Tuple{Dispatcher.Executor,AbstractArray{T&lt;:Dispatcher.DispatchNode,N},AbstractArray{S&lt;:Dispatcher.DispatchNode,N}}"><code>run!</code></a> for more.</p><h2><a class="nav-anchor" id="Further-Reading-1" href="#Further-Reading-1">Further Reading</a></h2><p>Check out the <a href="api.html#API-1">API</a> for more information.</p><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="api.html"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
