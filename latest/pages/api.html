<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Dispatcher.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/invenia.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Dispatcher.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="manual.html">Manual</a></li><li class="current"><a class="toctext" href="api.html">API</a><ul class="internal"><li><a class="toctext" href="#Nodes-1">Nodes</a></li><li><a class="toctext" href="#Graph-1">Graph</a></li><li><a class="toctext" href="#Executors-1">Executors</a></li><li><a class="toctext" href="#Errors-1">Errors</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">API</a></li></ul><a class="edit-page" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/docs/src/pages/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><h2><a class="nav-anchor" id="Nodes-1" href="#Nodes-1">Nodes</a></h2><h3><a class="nav-anchor" id="DispatchNode-1" href="#DispatchNode-1">DispatchNode</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.DispatchNode" href="#Dispatcher.DispatchNode"><code>Dispatcher.DispatchNode</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A <code>DispatchNode</code> represents a unit of computation that can be run. A <code>DispatchNode</code> may depend on other <code>DispatchNode</code>s, which are returned from the <a href="api.html#Dispatcher.dependencies-Tuple{Dispatcher.DispatchNode}"><code>dependencies</code></a> function.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L33-L37">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.get_label-Tuple{T&lt;:Dispatcher.DispatchNode}" href="#Dispatcher.get_label-Tuple{T&lt;:Dispatcher.DispatchNode}"><code>Dispatcher.get_label</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get_label(node::DispatchNode) -&gt; String</code></pre><p>Returns a node&#39;s label. By default, <code>DispatchNode</code>s do not support labels, so this method will error.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L50-L55">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.set_label!-Tuple{T&lt;:Dispatcher.DispatchNode,Any}" href="#Dispatcher.set_label!-Tuple{T&lt;:Dispatcher.DispatchNode,Any}"><code>Dispatcher.set_label!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">set_label!(node::DispatchNode, label)</code></pre><p>Sets a node&#39;s label. By default, <code>DispatchNode</code>s do not support labels, so this method will error. Actual method implementations should return their second argument.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L58-L64">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.has_label-Tuple{Dispatcher.DispatchNode}" href="#Dispatcher.has_label-Tuple{Dispatcher.DispatchNode}"><code>Dispatcher.has_label</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">has_label(node::DispatchNode) -&gt; Bool</code></pre><p>Returns true or false as to whether the node has a label (ie: a <a href="api.html#Dispatcher.get_label-Tuple{T&lt;:Dispatcher.DispatchNode}"><code>get_label(::DispatchNode)</code></a> method)</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L42-L47">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dependencies-Tuple{Dispatcher.DispatchNode}" href="#Dispatcher.dependencies-Tuple{Dispatcher.DispatchNode}"><code>Dispatcher.dependencies</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dependencies(node::DispatchNode) -&gt; Tuple{Vararg{DispatchNode}}</code></pre><p>Return all dependencies which must be ready before executing this node. Unless given a <code>dependencies</code> method, a <code>DispatchNode</code> will be assumed to have no dependencies.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L90-L96">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.prepare!-Tuple{Dispatcher.DispatchNode}" href="#Dispatcher.prepare!-Tuple{Dispatcher.DispatchNode}"><code>Dispatcher.prepare!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">prepare!(node::DispatchNode)</code></pre><p>Execute some action on a node before dispatching nodes via an <a href="api.html#Dispatcher.Executor"><code>Executor</code></a>. The default method performs no action.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L103-L108">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!-Tuple{Dispatcher.DispatchNode}" href="#Dispatcher.run!-Tuple{Dispatcher.DispatchNode}"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">run!(node::DispatchNode)</code></pre><p>Execute a node&#39;s action as part of dispatch. The default method performs no action.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L111-L116">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isready-Tuple{Dispatcher.DispatchNode}" href="#Base.isready-Tuple{Dispatcher.DispatchNode}"><code>Base.isready</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isready(node::DispatchNode) -&gt; Bool</code></pre><p>Determine whether a node has an available result. The default method assumes no synchronization is involved in retrieving that result.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L67-L72">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.wait-Tuple{Dispatcher.DispatchNode}" href="#Base.wait-Tuple{Dispatcher.DispatchNode}"><code>Base.wait</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">wait(node::DispatchNode)</code></pre><p>Block the current task until a node has a result available.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L75-L79">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fetch-Tuple{T&lt;:Dispatcher.DispatchNode}" href="#Base.fetch-Tuple{T&lt;:Dispatcher.DispatchNode}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">fetch(node::DispatchNode) -&gt; Any</code></pre><p>Fetch a node&#39;s result if available, blocking until it is available. All subtypes of <code>DispatchNode</code> should implement this, so the default method throws an error.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L82-L87">source</a><br/></section><h3><a class="nav-anchor" id="Op-1" href="#Op-1">Op</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.Op" href="#Dispatcher.Op"><code>Dispatcher.Op</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An <code>Op</code> is a <a href="api.html#Dispatcher.DispatchNode"><code>DispatchNode</code></a> which wraps a function which is executed when the <code>Op</code> is run. The result of that function call is stored in the <code>result</code> <code>DeferredFuture</code>. Any <code>DispatchNode</code>s which appear in the args or kwargs values will be noted as dependencies. This is the most common <code>DispatchNode</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L142-L149">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.Op-Tuple{Function}" href="#Dispatcher.Op-Tuple{Function}"><code>Dispatcher.Op</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Op(func::Function, args...; kwargs...) -&gt; Op</code></pre><p>Construct an <code>Op</code> which represents the delayed computation of <code>func(args...; kwargs)</code>. Any <a href="api.html#Dispatcher.DispatchNode"><code>DispatchNode</code></a>s which appear in the args or kwargs values will be noted as dependencies. The default label of an <code>Op</code> is the name of <code>func</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L158-L165">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.@op" href="#Dispatcher.@op"><code>Dispatcher.@op</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@op func(...)</code></pre><p>The <code>@op</code> macro makes it more convenient to construct <a href="api.html#Dispatcher.Op"><code>Op</code></a> nodes. It translates a function call into an <code>Op</code> call, effectively deferring the computation.</p><pre><code class="language-julia">a = @op sort(1:10; rev=true)</code></pre><p>is equivalent to</p><pre><code class="language-julia">a = Op(sort, 1:10; rev=true)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L176-L189">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.get_label-Tuple{Dispatcher.Op}" href="#Dispatcher.get_label-Tuple{Dispatcher.Op}"><code>Dispatcher.get_label</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get_label(op::Op) -&gt; String</code></pre><p>Returns the <code>op.label</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L249-L253">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.set_label!-Tuple{Dispatcher.Op,AbstractString}" href="#Dispatcher.set_label!-Tuple{Dispatcher.Op,AbstractString}"><code>Dispatcher.set_label!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">set_label!(op::Op, label::AbstractString)</code></pre><p>Set the op&#39;s label. Returns its second argument.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L256-L261">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.has_label-Tuple{Dispatcher.Op}" href="#Dispatcher.has_label-Tuple{Dispatcher.Op}"><code>Dispatcher.has_label</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">has_label(::Op) -&gt; Bool</code></pre><p>Always return <code>true</code> as an <code>Op</code> will always have a label.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L242-L246">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dependencies-Tuple{Dispatcher.Op}" href="#Dispatcher.dependencies-Tuple{Dispatcher.Op}"><code>Dispatcher.dependencies</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dependencies(op::Op) -&gt; Tuple{Verarg{DispatchNode}}</code></pre><p>Return all dependencies which must be ready before executing this <code>Op</code>. This will be all <a href="api.html#Dispatcher.DispatchNode"><code>DispatchNode</code></a>s in the <code>Op</code>&#39;s function <code>args</code> and <code>kwargs</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L264-L269">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.prepare!-Tuple{Dispatcher.Op}" href="#Dispatcher.prepare!-Tuple{Dispatcher.Op}"><code>Dispatcher.prepare!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">prepare!(op::Op)</code></pre><p>Replace an <code>Op</code>&#39;s result field with a fresh, empty one.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L307-L311">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!-Tuple{Dispatcher.Op}" href="#Dispatcher.run!-Tuple{Dispatcher.Op}"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">run!(op::Op)</code></pre><p>Fetch an <code>Op</code>&#39;s dependencies and execute its function. Store the result in its <code>result::DeferredFuture</code> field.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L317-L322">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isready-Tuple{Dispatcher.Op}" href="#Base.isready-Tuple{Dispatcher.Op}"><code>Base.isready</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isready(op::Op) -&gt; Bool</code></pre><p>Determine whether an <code>Op</code> has an available result.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L277-L281">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.wait-Tuple{Dispatcher.Op}" href="#Base.wait-Tuple{Dispatcher.Op}"><code>Base.wait</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">wait(op::Op)</code></pre><p>Wait until an <code>Op</code> has an available result.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L284-L288">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fetch-Tuple{Dispatcher.Op}" href="#Base.fetch-Tuple{Dispatcher.Op}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">fetch(op::Op) -&gt; Any</code></pre><p>Return the result of the <code>Op</code>. Block until it is available. Throw <a href="api.html#Dispatcher.DependencyError"><code>DependencyError</code></a> in the event that the result is a <code>DependencyError</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L291-L296">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.summary-Tuple{Dispatcher.Op}" href="#Base.summary-Tuple{Dispatcher.Op}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">summary(op::Op)</code></pre><p>Returns a string representation of the <code>Op</code> with its label and the args/kwargs types.</p><p><strong>NOTE</strong>: if an arg/kwarg is a <a href="api.html#Dispatcher.DispatchNode"><code>DispatchNode</code></a> with a label it will be printed with that arg.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L220-L228">source</a><br/></section><h3><a class="nav-anchor" id="DataNode-1" href="#DataNode-1">DataNode</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.DataNode" href="#Dispatcher.DataNode"><code>Dispatcher.DataNode</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A <code>DataNode</code> is a <code>DispatchNode</code> which wraps a piece of static data.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L119-L121">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fetch-Tuple{Dispatcher.DataNode}" href="#Base.fetch-Tuple{Dispatcher.DataNode}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">fetch{T}(node::DataNode{T}) -&gt; T</code></pre><p>Immediately return the data contained in a <code>DataNode</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L135-L139">source</a><br/></section><h3><a class="nav-anchor" id="IndexNode-1" href="#IndexNode-1">IndexNode</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.IndexNode" href="#Dispatcher.IndexNode"><code>Dispatcher.IndexNode</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An <code>IndexNode</code> refers to an element of the return value of a <a href="api.html#Dispatcher.DispatchNode"><code>DispatchNode</code></a>. It is meant to handle multiple return values from a <code>DispatchNode</code>.</p><p>Example:</p><pre><code class="language-julia">n1, n2 = Op(() -&gt; divrem(5, 2))
run!(exec, [n1, n2])

@assert fetch(n1) == 2
@assert fetch(n2) == 1</code></pre><p>In this example, <code>n1</code> and <code>n2</code> are created as <code>IndexNode</code>s pointing to the <a href="api.html#Dispatcher.Op"><code>Op</code></a> at index <code>1</code> and index <code>2</code> respectively.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L350-L365">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.IndexNode-Tuple{Dispatcher.DispatchNode,Int64}" href="#Dispatcher.IndexNode-Tuple{Dispatcher.DispatchNode,Int64}"><code>Dispatcher.IndexNode</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">IndexNode(node::DispatchNode, index) -&gt; IndexNode</code></pre><p>Create a new <code>IndexNode</code> referring to the result of <code>node</code> at <code>index</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L372-L376">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dependencies-Tuple{Dispatcher.IndexNode}" href="#Dispatcher.dependencies-Tuple{Dispatcher.IndexNode}"><code>Dispatcher.dependencies</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dependencies(node::IndexNode) -&gt; Tuple{DispatchNode}</code></pre><p>Return the dependency that this node will fetch data (at a certain index) from.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L397-L401">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.prepare!-Tuple{Dispatcher.IndexNode}" href="#Dispatcher.prepare!-Tuple{Dispatcher.IndexNode}"><code>Dispatcher.prepare!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">prepare!(node::IndexNode)</code></pre><p>Replace an <code>IndexNode</code>&#39;s result field with a fresh, empty one.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L427-L431">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!-Tuple{Dispatcher.IndexNode}" href="#Dispatcher.run!-Tuple{Dispatcher.IndexNode}"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">run!(node::IndexNode) -&gt; DeferredFuture</code></pre><p>Fetch data from the <code>IndexNode</code>&#39;s parent at the <code>IndexNode</code>&#39;s index, performing the indexing operation on the process where the data lives. Store the data from that index in a <code>DeferredFuture</code> in the <code>IndexNode</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L449-L455">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!-Tuple{Dispatcher.IndexNode{T&lt;:Union{Dispatcher.IndexNode,Dispatcher.Op}}}" href="#Dispatcher.run!-Tuple{Dispatcher.IndexNode{T&lt;:Union{Dispatcher.IndexNode,Dispatcher.Op}}}"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">run!(node::IndexNode) -&gt; DeferredFuture</code></pre><p>Fetch data from the <code>IndexNode</code>&#39;s parent at the <code>IndexNode</code>&#39;s index, performing the indexing operation on the process where the data lives. Store the data from that index in a <code>DeferredFuture</code> in the <code>IndexNode</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L437-L443">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isready-Tuple{Dispatcher.IndexNode}" href="#Base.isready-Tuple{Dispatcher.IndexNode}"><code>Base.isready</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isready(node::IndexNode) -&gt; Bool</code></pre><p>Determine whether an <code>IndexNode</code> has an available result.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L413-L417">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.wait-Tuple{Dispatcher.IndexNode}" href="#Base.wait-Tuple{Dispatcher.IndexNode}"><code>Base.wait</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">wait(node::IndexNode)</code></pre><p>Wait until an <code>IndexNode</code> has an available result.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L420-L424">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fetch-Tuple{Dispatcher.IndexNode}" href="#Base.fetch-Tuple{Dispatcher.IndexNode}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">fetch(node::IndexNode) -&gt; Any</code></pre><p>Return the stored result of indexing.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L404-L408">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.summary-Tuple{Dispatcher.IndexNode}" href="#Base.summary-Tuple{Dispatcher.IndexNode}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">summary(node::IndexNode)</code></pre><p>Returns a string representation of the <code>IndexNode</code> with a summary of the wrapped node and the node index.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L389-L394">source</a><br/></section><h3><a class="nav-anchor" id="CollectNode-1" href="#CollectNode-1">CollectNode</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.CollectNode" href="#Dispatcher.CollectNode"><code>Dispatcher.CollectNode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CollectNode{T&lt;:DispatchNode}(nodes::Vector{T}) -&gt; CollectNode{T}</code></pre><p>Create a node which gathers an array of nodes and stores an array of their results in its result field.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L546-L551">source</a><br/><div><pre><code class="language-none">CollectNode(nodes) -&gt; CollectNode{DispatchNode}</code></pre><p>Create a <code>CollectNode</code> from any iterable of nodes.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L563-L567">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.CollectNode-Tuple{Array{Dispatcher.DispatchNode,1}}" href="#Dispatcher.CollectNode-Tuple{Array{Dispatcher.DispatchNode,1}}"><code>Dispatcher.CollectNode</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">CollectNode{T&lt;:DispatchNode}(nodes::Vector{T}) -&gt; CollectNode{T}</code></pre><p>Create a node which gathers an array of nodes and stores an array of their results in its result field.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L546-L551">source</a><br/><div><pre><code class="language-none">CollectNode(nodes) -&gt; CollectNode{DispatchNode}</code></pre><p>Create a <code>CollectNode</code> from any iterable of nodes.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L563-L567">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.get_label-Tuple{Dispatcher.CollectNode}" href="#Dispatcher.get_label-Tuple{Dispatcher.CollectNode}"><code>Dispatcher.get_label</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get_label(node::CollectNode) -&gt; String</code></pre><p>Returns the node.label.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L626-L630">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.set_label!-Tuple{Dispatcher.CollectNode,AbstractString}" href="#Dispatcher.set_label!-Tuple{Dispatcher.CollectNode,AbstractString}"><code>Dispatcher.set_label!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">set_label!(node::CollectNode, label::AbstractString) -&gt; AbstractString</code></pre><p>Set the node&#39;s label. Returns its second argument.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L633-L638">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.has_label-Tuple{Dispatcher.CollectNode}" href="#Dispatcher.has_label-Tuple{Dispatcher.CollectNode}"><code>Dispatcher.has_label</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">has_label(::CollectNode) -&gt; Bool</code></pre><p>Always return <code>true</code> as a <code>CollectNode</code> will always have a label.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L641-L645">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dependencies-Tuple{Dispatcher.CollectNode}" href="#Dispatcher.dependencies-Tuple{Dispatcher.CollectNode}"><code>Dispatcher.dependencies</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dependencies{T&lt;:DispatchNode}(node::CollectNode{T}) -&gt; Vector{T}</code></pre><p>Return the nodes this depends on which this node will collect.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L570-L574">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.prepare!-Tuple{Dispatcher.CollectNode}" href="#Dispatcher.prepare!-Tuple{Dispatcher.CollectNode}"><code>Dispatcher.prepare!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">prepare!(node::CollectNode)</code></pre><p>Initialize a <code>CollectNode</code> with a fresh result <code>DeferredFuture</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L599-L603">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!-Tuple{Dispatcher.CollectNode}" href="#Dispatcher.run!-Tuple{Dispatcher.CollectNode}"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">run!(node::CollectNode)</code></pre><p>Collect all of a <code>CollectNode</code>&#39;s dependencies&#39; results into a Vector and store that in this node&#39;s result field. Returns <code>nothing</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L609-L615">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isready-Tuple{Dispatcher.CollectNode}" href="#Base.isready-Tuple{Dispatcher.CollectNode}"><code>Base.isready</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isready(node::CollectNode) -&gt; Bool</code></pre><p>Determine whether a <code>CollectNode</code> has an available result.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L585-L589">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.wait-Tuple{Dispatcher.CollectNode}" href="#Base.wait-Tuple{Dispatcher.CollectNode}"><code>Base.wait</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">wait(node::CollectNode)</code></pre><p>Block until a <code>CollectNode</code> has an available result.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L592-L596">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fetch-Tuple{Dispatcher.CollectNode}" href="#Base.fetch-Tuple{Dispatcher.CollectNode}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">fetch(node::CollectNode) -&gt; Vector</code></pre><p>Return the result of the collection. Block until it is available.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L577-L582">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.summary-Tuple{Dispatcher.CollectNode}" href="#Base.summary-Tuple{Dispatcher.CollectNode}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">summary(node::CollectNode)</code></pre><p>Returns a string representation of the <code>CollectNode</code> with its label.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L660-L664">source</a><br/></section><h2><a class="nav-anchor" id="Graph-1" href="#Graph-1">Graph</a></h2><h3><a class="nav-anchor" id="DispatchGraph-1" href="#DispatchGraph-1">DispatchGraph</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.DispatchGraph" href="#Dispatcher.DispatchGraph"><code>Dispatcher.DispatchGraph</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>DispatchGraph</code> wraps a directed graph from <code>LightGraphs</code> and a bidirectional dictionary mapping between <code>DispatchNode</code> instances and vertex numbers in the graph.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/graph.jl#L1-L5">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.nodes-Tuple{Dispatcher.DispatchGraph}" href="#Dispatcher.nodes-Tuple{Dispatcher.DispatchGraph}"><code>Dispatcher.nodes</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">nodes(graph::DispatchGraph) -&gt;</code></pre><p>Return an iterable of all nodes stored in the <code>DispatchGraph</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/graph.jl#L109-L113">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length-Tuple{Dispatcher.DispatchGraph}" href="#Base.length-Tuple{Dispatcher.DispatchGraph}"><code>Base.length</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">length(graph::DispatchGraph) -&gt; Integer</code></pre><p>Return the number of nodes in the graph.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/graph.jl#L76-L80">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Tuple{Dispatcher.DispatchGraph,Dispatcher.DispatchNode}" href="#Base.push!-Tuple{Dispatcher.DispatchGraph,Dispatcher.DispatchNode}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">push!(graph::DispatchGraph, node::DispatchNode) -&gt; DispatchGraph</code></pre><p>Add a node to the graph and return the graph.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/graph.jl#L83-L87">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.add_edge!-Tuple{Dispatcher.DispatchGraph,Dispatcher.DispatchNode,Dispatcher.DispatchNode}" href="#LightGraphs.add_edge!-Tuple{Dispatcher.DispatchGraph,Dispatcher.DispatchNode,Dispatcher.DispatchNode}"><code>LightGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">add_edge!(graph::DispatchGraph, parent::DispatchNode, child::DispatchNode) -&gt; Bool</code></pre><p>Add an edge to the graph from <code>parent</code> to <code>child</code>. Return whether the operation was successful.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/graph.jl#L95-L100">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Tuple{Dispatcher.DispatchGraph,Dispatcher.DispatchGraph}" href="#Base.:==-Tuple{Dispatcher.DispatchGraph,Dispatcher.DispatchGraph}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">graph1::DispatchGraph == graph2::DispatchGraph</code></pre><p>Determine whether two graphs have the same nodes and edges. This is an expensive operation.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/graph.jl#L169-L174">source</a><br/></section><h2><a class="nav-anchor" id="Executors-1" href="#Executors-1">Executors</a></h2><h3><a class="nav-anchor" id="Executor-1" href="#Executor-1">Executor</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.Executor" href="#Dispatcher.Executor"><code>Dispatcher.Executor</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An <code>Executor</code> handles execution of <a href="api.html#Dispatcher.DispatchGraph"><code>DispatchGraph</code></a>s.</p><p>A type <code>T &lt;: Executor</code> must implement <code>dispatch!(::T, ::DispatchNode)</code> and may optionally implement <code>dispatch!(::T, ::DispatchGraph; throw_error=true)</code>.</p><p>The function call tree will look like this when an executor is run:</p><pre><code class="language-none">run!(exec, context)
    prepare!(exec, context)
        prepare!(nodes[i])
    dispatch!(exec, context)
        dispatch!(exec, nodes[i])
            run!(nodes[i])</code></pre><p>NOTE: Currently, it is expected that <code>dispatch!(::T, ::DispatchNode)</code> returns something to wait on (ie: <code>Task</code>, <code>Future</code>, <code>Channel</code>, <a href="api.html#Dispatcher.DispatchNode"><code>DispatchNode</code></a>, etc)</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L9-L27">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!-Tuple{Dispatcher.Executor,AbstractArray{T&lt;:Dispatcher.DispatchNode,N},AbstractArray{S&lt;:Dispatcher.DispatchNode,N}}" href="#Dispatcher.run!-Tuple{Dispatcher.Executor,AbstractArray{T&lt;:Dispatcher.DispatchNode,N},AbstractArray{S&lt;:Dispatcher.DispatchNode,N}}"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">run!(exec, output_nodes, input_nodes; input_map, throw_error) -&gt; DispatchResult</code></pre><p>Create a graph, ending in <code>output_nodes</code>, and using <code>input_nodes</code>/<code>input_map</code> to replace nodes with fixed values (and ignoring nodes for which all paths descend to <code>input_nodes</code>), then execute it.</p><p><strong>Arguments</strong></p><ul><li><p><code>exec::Executor</code>: the executor which will execute the graph</p></li><li><p><code>graph::DispatchGraph</code>: the graph which will be executed</p></li><li><p><code>output_nodes::AbstractArray{T&lt;:DispatchNode}</code>: the nodes whose results we are interested in</p></li><li><p><code>input_nodes::AbstractArray{T&lt;:DispatchNode}</code>: &quot;root&quot; nodes of the graph which will be replaced with their fetched values (dependencies of these nodes are not included in the graph)</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>input_map::Associative=Dict{DispatchNode, Any}()</code>: dict keys are &quot;root&quot; nodes of the subgraph which will be replaced with the dict values (dependencies of these nodes are not included in the graph)</p></li><li><p><code>throw_error::Bool</code>: whether to throw any <a href="api.html#Dispatcher.DependencyError"><code>DependencyError</code></a>s immediately (see <a href="api.html#Dispatcher.dispatch!-Tuple{Dispatcher.Executor,Dispatcher.DispatchGraph}"><code>dispatch!(::Executor, ::DispatchGraph)</code></a> for more information)</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>Vector{DispatchResult}</code>: an array containing a <code>DispatchResult</code> for each node in <code>output_nodes</code>, in that order.</p></li></ul><p><strong>Throws</strong></p><ul><li><p><code>ExecutorError</code>: if the constructed graph contains a cycle</p></li><li><p><code>CompositeException</code>/<a href="api.html#Dispatcher.DependencyError"><code>DependencyError</code></a>: see documentation for <a href="api.html#Dispatcher.dispatch!-Tuple{Dispatcher.Executor,Dispatcher.DispatchGraph}"><code>dispatch!(::Executor, ::DispatchGraph)</code></a></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L51-L86">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!-Tuple{Dispatcher.Executor,Dispatcher.DispatchGraph}" href="#Dispatcher.run!-Tuple{Dispatcher.Executor,Dispatcher.DispatchGraph}"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">run!(exec::Executor, graph::DispatchGraph; kwargs...)</code></pre><p>The <code>run!</code> function prepares a <a href="api.html#Dispatcher.DispatchGraph"><code>DispatchGraph</code></a> for dispatch and then dispatches <a href="api.html#Dispatcher.run!-Tuple{Dispatcher.DispatchNode}"><code>run!(::DispatchNode)</code></a> calls for all nodes in its graph.</p><p>Users will almost never want to add methods to this function for different <a href="api.html#Dispatcher.Executor"><code>Executor</code></a> subtypes; overriding <a href="api.html#Dispatcher.dispatch!-Tuple{Dispatcher.Executor,Dispatcher.DispatchGraph}"><code>dispatch!(::Executor, ::DispatchGraph)</code></a> is the preferred pattern.</p><p>Return an array containing a <code>Result{DispatchNode, DependencyError}</code> for each leaf node.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L115-L126">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.prepare!-Tuple{Dispatcher.Executor,Dispatcher.DispatchGraph}" href="#Dispatcher.prepare!-Tuple{Dispatcher.Executor,Dispatcher.DispatchGraph}"><code>Dispatcher.prepare!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">prepare!(exec::Executor, graph::DispatchGraph)</code></pre><p>This function prepares a context for execution. Call <a href="api.html#Dispatcher.prepare!-Tuple{Dispatcher.DispatchNode}"><code>prepare!(::DispatchNode)</code></a> on each node.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L137-L142">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dispatch!-Tuple{Dispatcher.Executor,Dispatcher.DispatchGraph}" href="#Dispatcher.dispatch!-Tuple{Dispatcher.Executor,Dispatcher.DispatchGraph}"><code>Dispatcher.dispatch!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dispatch!(exec::Executor, graph::DispatchGraph; throw_error=true) -&gt; Vector</code></pre><p>The default <code>dispatch!</code> method uses <code>asyncmap</code> over all nodes in the context to call <code>dispatch!(exec, node)</code>. These <code>dispatch!</code> calls for each node are wrapped in various retry and error handling methods.</p><p><strong>Wrapping Details</strong></p><ol><li><p>All nodes are wrapped in a try catch which waits on the value returned from the <code>dispatch!(exec, node)</code> call. Any errors are caught and used to create <a href="api.html#Dispatcher.DependencyError"><code>DependencyError</code></a>s which are thrown. If no errors are produced then the node is returned.</p><p><strong>NOTE</strong>: All errors thrown by trying to run <code>dispatch!(exec, node)</code> are wrapped in a <code>DependencyError</code>.</p></li><li><p>The aformentioned wrapper function is used in a retry wrapper to rerun failed nodes (up to some limit). The wrapped function will only be retried iff the error produced by <code>dispatch!(::Executor, ::DispatchNode</code>) passes one of the retry functions specific to that <a href="api.html#Dispatcher.Executor"><code>Executor</code></a>. By default the <a href="api.html#Dispatcher.AsyncExecutor"><code>AsyncExecutor</code></a> has no <a href="api.html#Dispatcher.retry_on-Tuple{Dispatcher.Executor}"><code>retry_on</code></a> functions and the <a href="api.html#Dispatcher.ParallelExecutor"><code>ParallelExecutor</code></a> only has <code>retry_on</code> functions related to the loss of a worker process during execution.</p></li><li><p>A node may enter a failed state if it exits the retry wrapper with an exception. This may occur if an exception is thrown while executing a node and it does not pass any of the <code>retry_on</code> conditions for the <code>Executor</code> or too many attempts to run the node have been made. In the situation where a node has entered a failed state and the node is an <code>Op</code> then the <code>op.result</code> is set to the <code>DependencyError</code>, signifying the node&#39;s failure to any dependent nodes. Finally, if <code>throw_error</code> is true then the <code>DependencyError</code> will be immediately thrown in the current process without allowing other nodes to finish. If <code>throw_error</code> is false then the <code>DependencyError</code> is not thrown and it will be returned in the array of passing and failing nodes.</p></li></ol><p><strong>Arguments</strong></p><ul><li><p><code>exec::Executor</code>: the executor we&#39;re running</p></li><li><p><code>graph::DispatchGraph</code>: the context of nodes to run</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>throw_error::Bool=true</code>: whether or not to throw the <code>DependencyError</code> for failed nodes</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>Vector{Union{DispatchNode, DependencyError}}</code>: a list of <a href="api.html#Dispatcher.DispatchNode"><code>DispatchNode</code></a>s or <code>DependencyError</code>s for failed nodes</p></li></ul><p><strong>Throws</strong></p><ul><li><p><code>dispatch!</code> has the same behaviour on exceptions as <code>asyncmap</code> and <code>pmap</code>. In 0.5 this will throw a <code>CompositeException</code> containing <code>DependencyError</code>s, while in 0.6 this will simply throw the first <code>DependencyError</code>.</p></li></ul><p><strong>Usage</strong></p><p><strong>Example 1</strong></p><p>Assuming we have some uncaught application error:</p><pre><code class="language-julia">exec = AsyncExecutor()
n1 = Op(() -&gt; 3)
n2 = Op(() -&gt; 4)
failing_node = Op(() -&gt; throw(ErrorException(&quot;ApplicationError&quot;)))
dep_node = Op(n -&gt; println(n), failing_node)  # This node will fail as well
graph = DispatchGraph([n1, n2, failing_node, dep_node])</code></pre><p>Then <code>dispatch!(exec, graph)</code> will throw a <code>DependencyError</code> and <code>dispatch!(exec, graph; throw_error=false)</code> will return an array of passing nodes and the <code>DependencyError</code>s (ie: <code>[n1, n2, DependencyError(...), DependencyError(...)]</code>).</p><p><strong>Example 2</strong></p><p>Now if we want to retry our node on certain errors we can do:</p><pre><code class="language-julia">exec = AsyncExecutor(5, [e -&gt; isa(e, HttpError) &amp;&amp; e.status == &quot;503&quot;])
n1 = Op(() -&gt; 3)
n2 = Op(() -&gt; 4)
http_node = Op(() -&gt; http_get(...))
graph = DispatchGraph([n1, n2, http_node])</code></pre><p>Assuming that the <code>http_get</code> function does not error 5 times the call to <code>dispatch!(exec, graph)</code> will return [n1, n2, http_node]. If the <code>http_get</code> function either:</p><ol><li><p>fails with a different status code</p></li><li><p>fails with something other than an <code>HttpError</code> or</p></li><li><p>throws an <code>HttpError</code> with status &quot;503&quot; more than 5 times</p></li></ol><p>then we&#39;ll see the same failure behaviour as in the previous example.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L151-L249">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run_inner_node!-Tuple{Dispatcher.Executor,Dispatcher.DispatchNode,Int64}" href="#Dispatcher.run_inner_node!-Tuple{Dispatcher.Executor,Dispatcher.DispatchNode,Int64}"><code>Dispatcher.run_inner_node!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">run_inner_node!(exec::Executor, node::DispatchNode, id::Int)</code></pre><p>Run the <code>DispatchNode</code> in the <code>DispatchGraph</code> at position <code>id</code>. Any error thrown during the node&#39;s execution is caught and wrapped in a <a href="api.html#Dispatcher.DependencyError"><code>DependencyError</code></a>.</p><p>Typical <a href="api.html#Dispatcher.Executor"><code>Executor</code></a> implementations should not need to override this.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L365-L372">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.retries-Tuple{Dispatcher.Executor}" href="#Dispatcher.retries-Tuple{Dispatcher.Executor}"><code>Dispatcher.retries</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">retries(exec::Executor) -&gt; Int</code></pre><p>Return the number of retries an executor should perform while attempting to run a node before giving up. The default <code>retries</code> method returns <code>0</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L34-L39">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.retry_on-Tuple{Dispatcher.Executor}" href="#Dispatcher.retry_on-Tuple{Dispatcher.Executor}"><code>Dispatcher.retry_on</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">retry_on(exec::Executor) -&gt; Vector{Function}</code></pre><p>Return the vector of predicates which accept an <code>Exception</code> and return <code>true</code> if a node can and should be retried (and <code>false</code> otherwise). The default <code>retry_on</code> method returns <code>Function[]</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L42-L48">source</a><br/></section><h3><a class="nav-anchor" id="AsyncExecutor-1" href="#AsyncExecutor-1">AsyncExecutor</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.AsyncExecutor" href="#Dispatcher.AsyncExecutor"><code>Dispatcher.AsyncExecutor</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>AsyncExecutor</code> is an <a href="api.html#Dispatcher.Executor"><code>Executor</code></a> which schedules a local Julia <code>Task</code> for each <a href="api.html#Dispatcher.DispatchNode"><code>DispatchNode</code></a> and waits for them to complete. <code>AsyncExecutor</code>&#39;s <a href="api.html#Dispatcher.dispatch!-Tuple{Dispatcher.AsyncExecutor,Dispatcher.DispatchNode}"><code>dispatch!(::AsyncExecutor, ::DispatchNode)</code></a> method will complete as long as each <code>DispatchNode</code>&#39;s <a href="api.html#Dispatcher.run!-Tuple{Dispatcher.DispatchNode}"><code>run!(::DispatchNode)</code></a> method completes and there are no cycles in the computation graph.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L407-L413">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.AsyncExecutor-Tuple{}" href="#Dispatcher.AsyncExecutor-Tuple{}"><code>Dispatcher.AsyncExecutor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">AsyncExecutor(retries=5, retry_on::Vector{Function}=Function[]) -&gt; AsyncExecutor</code></pre><p><code>retries</code> is the number of times the executor is to retry a failed node. <code>retry_on</code> is a vector of predicates which accept an <code>Exception</code> and return <code>true</code> if a node can and should be retried (and <code>false</code> otherwise).</p><p>Return a new <code>AsyncExecutor</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L419-L427">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dispatch!-Tuple{Dispatcher.AsyncExecutor,Dispatcher.DispatchNode}" href="#Dispatcher.dispatch!-Tuple{Dispatcher.AsyncExecutor,Dispatcher.DispatchNode}"><code>Dispatcher.dispatch!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dispatch!(exec::AsyncExecutor, node::DispatchNode) -&gt; Task</code></pre><p><code>dispatch!</code> takes the <code>AsyncExecutor</code> and a <code>DispatchNode</code> to run. The <a href="api.html#Dispatcher.run!-Tuple{Dispatcher.DispatchNode}"><code>run!(::DispatchNode)</code></a> method on the node is called within a <code>@schedule</code> block and the resulting <code>Task</code> is returned. This is the defining method of <code>AsyncExecutor</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L432-L439">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.retries-Tuple{Dispatcher.AsyncExecutor}" href="#Dispatcher.retries-Tuple{Dispatcher.AsyncExecutor}"><code>Dispatcher.retries</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">retries(exec::Executor) -&gt; Int</code></pre><p>Return the number of retries an executor should perform while attempting to run a node before giving up. The default <code>retries</code> method returns <code>0</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L34-L39">source</a><br/><div><pre><code class="language-none">retries(exec::Union{AsyncExecutor, ParallelExecutor}) -&gt; Int</code></pre><p>Return the number of retries per node.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L506-L510">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.retry_on-Tuple{Dispatcher.AsyncExecutor}" href="#Dispatcher.retry_on-Tuple{Dispatcher.AsyncExecutor}"><code>Dispatcher.retry_on</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">retry_on(exec::Executor) -&gt; Vector{Function}</code></pre><p>Return the vector of predicates which accept an <code>Exception</code> and return <code>true</code> if a node can and should be retried (and <code>false</code> otherwise). The default <code>retry_on</code> method returns <code>Function[]</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L42-L48">source</a><br/><div><pre><code class="language-none">retry_on(exec::Union{AsyncExecutor, ParallelExecutor}) -&gt; Vector{Function}</code></pre><p>Return the array of retry conditions.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L513-L517">source</a><br/></section><h3><a class="nav-anchor" id="ParallelExecutor-1" href="#ParallelExecutor-1">ParallelExecutor</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.ParallelExecutor" href="#Dispatcher.ParallelExecutor"><code>Dispatcher.ParallelExecutor</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>ParallelExecutor</code> is an <a href="api.html#Dispatcher.Executor"><code>Executor</code></a> which creates a Julia <code>Task</code> for each <a href="api.html#Dispatcher.DispatchNode"><code>DispatchNode</code></a>, spawns each of those tasks on the processes available to Julia, and waits for them to complete. <code>ParallelExecutor</code>&#39;s <a href="api.html#Dispatcher.dispatch!-Tuple{Dispatcher.Executor,Dispatcher.DispatchGraph}"><code>dispatch!(::ParallelExecutor, ::DispatchGraph)</code></a> method will complete as long as each <code>DispatchNode</code>&#39;s <a href="api.html#Dispatcher.run!-Tuple{Dispatcher.DispatchNode}"><code>run!(::DispatchNode)</code></a> method completes and there are no cycles in the computation graph.</p><pre><code class="language-none">ParallelExecutor(retries=5, retry_on::Vector{Function}=Function[]) -&gt; ParallelExecutor</code></pre><p><code>retries</code> is the number of times the executor is to retry a failed node. <code>retry_on</code> is a vector of predicates which accept an <code>Exception</code> and return <code>true</code> if a node can and should be retried (and <code>false</code> otherwise). Returns a new <code>ParallelExecutor</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L442-L456">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dispatch!-Tuple{Dispatcher.ParallelExecutor,Dispatcher.DispatchNode}" href="#Dispatcher.dispatch!-Tuple{Dispatcher.ParallelExecutor,Dispatcher.DispatchNode}"><code>Dispatcher.dispatch!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dispatch!(exec::ParallelExecutor, node::DispatchNode) -&gt; Future</code></pre><p><code>dispatch!</code> takes the <code>ParallelExecutor</code> and a <a href="api.html#Dispatcher.DispatchNode"><code>DispatchNode</code></a> to run. The <a href="api.html#Dispatcher.run!-Tuple{Dispatcher.DispatchNode}"><code>run!(::DispatchNode)</code></a> method on the node is called within an <code>@spawn</code> block and the resulting <code>Future</code> is returned. This is the defining method of <code>ParallelExecutor</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L496-L503">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.retries-Tuple{Dispatcher.ParallelExecutor}" href="#Dispatcher.retries-Tuple{Dispatcher.ParallelExecutor}"><code>Dispatcher.retries</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">retries(exec::Executor) -&gt; Int</code></pre><p>Return the number of retries an executor should perform while attempting to run a node before giving up. The default <code>retries</code> method returns <code>0</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L34-L39">source</a><br/><div><pre><code class="language-none">retries(exec::Union{AsyncExecutor, ParallelExecutor}) -&gt; Int</code></pre><p>Return the number of retries per node.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L506-L510">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.retry_on-Tuple{Dispatcher.ParallelExecutor}" href="#Dispatcher.retry_on-Tuple{Dispatcher.ParallelExecutor}"><code>Dispatcher.retry_on</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">retry_on(exec::Executor) -&gt; Vector{Function}</code></pre><p>Return the vector of predicates which accept an <code>Exception</code> and return <code>true</code> if a node can and should be retried (and <code>false</code> otherwise). The default <code>retry_on</code> method returns <code>Function[]</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L42-L48">source</a><br/><div><pre><code class="language-none">retry_on(exec::Union{AsyncExecutor, ParallelExecutor}) -&gt; Vector{Function}</code></pre><p>Return the array of retry conditions.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/executors.jl#L513-L517">source</a><br/></section><h2><a class="nav-anchor" id="Errors-1" href="#Errors-1">Errors</a></h2><h3><a class="nav-anchor" id="DependencyError-1" href="#DependencyError-1">DependencyError</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.DependencyError" href="#Dispatcher.DependencyError"><code>Dispatcher.DependencyError</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>DependencyError</code> wraps any errors (and corresponding traceback) that occur on the dependency of a given nodes.</p><p>This is important for passing failure conditions to dependent nodes after a failed number of retries.</p><p><strong>NOTE</strong>: our <code>trace</code> field is a Union of <code>Vector{Any}</code> and <code>StackTrace</code> because we could be storing the traceback from a <code>CompositeException</code> (inside a <code>RemoteException</code>) which is of type <code>Vector{Any}</code></p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L3-L13">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.summary-Tuple{Dispatcher.DependencyError}" href="#Base.summary-Tuple{Dispatcher.DependencyError}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">summary(de::DependencyError)</code></pre><p>Retuns a string representation of the error with only the internal <code>Exception</code> type and the <code>id</code></p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/a769e68e00153e42b2ffa6e140a5c8fd06c40a76/src/nodes.jl#L22-L27">source</a><br/></section><footer><hr/><a class="previous" href="manual.html"><span class="direction">Previous</span><span class="title">Manual</span></a></footer></article></body></html>
